# WORKER AGENT MONOREPO – DIRECTORY + ALAP KÓD STRUKTÚRA
# (Cloudflare Workers + multi-agent setup)

.
├─ wrangler.toml
├─ package.json
├─ tsconfig.json
├─ README.md
└─ src
   ├─ index.ts              # fő belépési pont (Worker)
   ├─ router.ts             # route-olás / HTTP endpointok
   ├─ env.d.ts              # környezeti változók típusai
   ├─ lib
   │  ├─ openaiClient.ts    # OpenAI / AI kliens wrapper
   │  ├─ utils.ts           # közös helper függvények
   │  └─ logging.ts         # logolás, trace
   ├─ agents
   │  ├─ index.ts           # agent registry / router
   │  ├─ baseAgent.ts       # absztrakt ős agent
   │  ├─ orchestratorAgent.ts # delegáló / controller agent
   │  ├─ researcherAgent.ts # kutató / info gyűjtő agent
   │  ├─ coderAgent.ts      # kód generáló / refaktoráló agent
   │  └─ executorAgent.ts   # “node exec / tools” végrehajtó agent
   └─ tools
      ├─ nodeExec.ts        # sandboxolt “node exec” jellegű tool
      ├─ fetchUrl.ts        # HTTP fetch tool
      └─ kvStore.ts         # KV / Durable Object wrapper

# ==== FÁJLOK TARTALMA ====

# wrangler.toml
name = "worker-agent-matrix"
main = "src/index.ts"
compatibility_date = "2025-11-21"
compatibility_flags = ["nodejs_compat"]

[vars]
# OPENAI kulcs, stb. (Cloudflare dashboardon töltsd ki)
OPENAI_API_KEY = ""

# KV / DO / R2 példák:
# [[kv_namespaces]]
# binding = "AGENT_KV"
# id = "xxxxxxxxxxxxxxxxxxxxxxx"

[observability]
enabled = true

# ==========================

# package.json
{
  "name": "worker-agent-matrix",
  "version": "1.0.0",
  "private": true,
  "scripts": {
    "dev": "wrangler dev",
    "deploy": "wrangler deploy",
    "format": "prettier --write .",
    "typecheck": "tsc --noEmit"
  },
  "devDependencies": {
    "@cloudflare/workers-types": "^4.20241112.0",
    "typescript": "^5.6.0",
    "prettier": "^3.3.0"
  },
  "dependencies": {
    "openai": "^4.68.0"
  }
}

# ==========================

# tsconfig.json
{
  "compilerOptions": {
    "target": "ES2022",
    "module": "ESNext",
    "moduleResolution": "Bundler",
    "strict": true,
    "allowJs": false,
    "noEmit": true,
    "types": ["@cloudflare/workers-types"],
    "baseUrl": "./src",
    "paths": {
      "@agents/*": ["agents/*"],
      "@lib/*": ["lib/*"],
      "@tools/*": ["tools/*"]
    }
  },
  "include": ["src"]
}

# ==========================

# src/env.d.ts
export interface Env {
  OPENAI_API_KEY: string;
  // AGENT_KV: KVNamespace;       // ha használsz KV-t
}

# ==========================

# src/lib/openaiClient.ts
import OpenAI from "openai";
import type { Env } from "../env";

export const createOpenAI = (env: Env) => {
  return new OpenAI({
    apiKey: env.OPENAI_API_KEY
  });
};

# ==========================

# src/lib/utils.ts
export function jsonResponse(data: unknown, init: ResponseInit = {}) {
  return new Response(JSON.stringify(data, null, 2), {
    headers: {
      "Content-Type": "application/json; charset=utf-8"
    },
    ...init
  });
}

export function errorResponse(message: string, status = 400) {
  return jsonResponse({ error: message }, { status });
}

# ==========================

# src/lib/logging.ts
export function log(...args: unknown[]) {
  // Worker log -> wrangler dev / Cloudflare logs
  console.log("[AGENT]", ...args);
}

# ==========================

# src/agents/baseAgent.ts
import type { Env } from "../env";

export type AgentContext = {
  env: Env;
  requestId?: string;
};

export type AgentInput = {
  task: string;
  meta?: Record<string, unknown>;
};

export type AgentOutput = {
  result: string;
  reasoning?: string;
  meta?: Record<string, unknown>;
};

export interface Agent {
  name: string;
  description: string;
  handle(input: AgentInput, ctx: AgentContext): Promise<AgentOutput>;
}

# ==========================

# src/agents/orchestratorAgent.ts
import type { Agent, AgentInput, AgentOutput, AgentContext } from "./baseAgent";
import { log } from "../lib/logging";
import { getAgentRegistry } from "./index";

export class OrchestratorAgent implements Agent {
  name = "orchestrator";
  description =
    "Feladat-orchestrator agent, ami továbbküldi a taskot a megfelelő specialista agentnek.";

  async handle(input: AgentInput, ctx: AgentContext): Promise<AgentOutput> {
    log("Orchestrator received task:", input.task);

    const registry = getAgentRegistry();
    const lower = input.task.toLowerCase();

    let targetName: string;

    if (lower.includes("kutat") || lower.includes("research")) {
      targetName = "researcher";
    } else if (lower.includes("kód") || lower.includes("code")) {
      targetName = "coder";
    } else if (lower.includes("futtasd") || lower.includes("exec")) {
      targetName = "executor";
    } else {
      // default fallback
      targetName = "researcher";
    }

    const target = registry[targetName];
    if (!target) {
      return {
        result: `Nincs megfelelő agent a feladatra (${targetName}).`,
        reasoning: "Registry-ben nem található a kért agent."
      };
    }

    const res = await target.handle(input, ctx);

    return {
      ...res,
      meta: {
        ...(res.meta || {}),
        routedBy: this.name,
        targetAgent: target.name
      }
    };
  }
}

# ==========================

# src/agents/researcherAgent.ts
import type { Agent, AgentInput, AgentOutput, AgentContext } from "./baseAgent";
import { createOpenAI } from "../lib/openaiClient";

export class ResearcherAgent implements Agent {
  name = "researcher";
  description =
    "Kutató agent – összefoglal, ötletel, információt strukturál.";

  async handle(input: AgentInput, ctx: AgentContext): Promise<AgentOutput> {
    const openai = createOpenAI(ctx.env);

    const completion = await openai.responses.create({
      model: "gpt-4.1-mini",
      input: [
        {
          role: "system",
          content:
            "Rövid, strukturált magyar összefoglalókat írj, bulletpontokkal, ha lehet."
        },
        { role: "user", content: input.task }
      ]
    });

    const text =
      completion.output[0].content[0].type === "output_text"
        ? completion.output[0].content[0].text
        : "Nincs szöveges válasz.";

    return {
      result: text,
      reasoning: "ResearcherAgent OpenAI modellel generált összefoglalót."
    };
  }
}

# ==========================

# src/agents/coderAgent.ts
import type { Agent, AgentInput, AgentOutput, AgentContext } from "./baseAgent";
import { createOpenAI } from "../lib/openaiClient";

export class CoderAgent implements Agent {
  name = "coder";
  description =
    "Kód generáló / refaktoráló agent – TypeScript / JS példákra optimalizálva.";

  async handle(input: AgentInput, ctx: AgentContext): Promise{AgentOutput} {
    const openai = createOpenAI(ctx.env);

    const completion = await openai.responses.create({
      model: "gpt-4.1",
      input: [
        {
          role: "system",
          content:
            "Te egy senior TypeScript/Cloudflare Workers fejlesztő vagy. Adj production-közeli kódot."
        },
        { role: "user", content: input.task }
      ]
    });

    const text =
      completion.output[0].content[0].type === "output_text"
        ? completion.output[0].content[0].text
        : "Nincs szöveges válasz.";

    return {
      result: text,
      reasoning: "CoderAgent kód-jellegű outputot generált."
    };
  }
}

# ==========================

# src/agents/executorAgent.ts
import type { Agent, AgentInput, AgentOutput, AgentContext } from "./baseAgent";
import { runNodeExecTool } from "../tools/nodeExec";

export class ExecutorAgent implements Agent {
  name = "executor";
  description =
    "Node exec / tool végrehajtó agent. Very careful, sandbox-only.";

  async handle(input: AgentInput, ctx: AgentContext): Promise<AgentOutput> {
    const code = String(input.meta?.code ?? input.task);

    const output = await runNodeExecTool(code);

    return {
      result: output.stdout ?? "",
      reasoning:
        "ExecutorAgent lefuttatott egy sandboxolt nodeExec toolt (stdout visszaadva).",
      meta: {
        ...output,
        limited: true
      }
    };
  }
}

# ==========================

# src/agents/index.ts
import type { Agent } from "./baseAgent";
import { OrchestratorAgent } from "./orchestratorAgent";
import { ResearcherAgent } from "./researcherAgent";
import { CoderAgent } from "./coderAgent";
import { ExecutorAgent } from "./executorAgent";

let registry: Record<string, Agent> | null = null;

export function getAgentRegistry(): Record<string, Agent> {
  if (!registry) {
    const orchestrator = new OrchestratorAgent();
    const researcher = new ResearcherAgent();
    const coder = new CoderAgent();
    const executor = new ExecutorAgent();

    registry = {
      [orchestrator.name]: orchestrator,
      [researcher.name]: researcher,
      [coder.name]: coder,
      [executor.name]: executor
    };
  }
  return registry!;
}

# ==========================

# src/tools/nodeExec.ts
// FIGYELEM: ez csak példa. Itt valójában NEM futtatsz raw Node-ot Workerben,
// hanem valamilyen safe mini-interpreter / sandbox logika menjen.
// Most dummy implementáció van.

type ExecResult = {
  stdout: string;
  stderr?: string;
};

export async function runNodeExecTool(code: string): Promise<ExecResult> {
  // Itt tudsz "code" alapján valami safe dolgot csinálni,
  // pl. mini JS interpreter, vagy predef parancs router.
  // DEMO:
  return {
    stdout: `⚠️ Demo nodeExec: itt futna a kód, de most csak echo:\n${code}`
  };
}

# ==========================

# src/tools/fetchUrl.ts
export async function fetchUrl(url: string): Promise<string> {
  const res = await fetch(url);
  if (!res.ok) {
    throw new Error(`Fetch error ${res.status}: ${res.statusText}`);
  }
  return await res.text();
}

# ==========================

# src/tools/kvStore.ts
// Példa KV wrapperhez – ha wrangler.toml-ben bekötöd az AGENT_KV-t.
/*
import type { Env } from "../env";

export async function kvSet(env: Env, key: string, value: string) {
  await env.AGENT_KV.put(key, value);
}

export async function kvGet(env: Env, key: string) {
  return env.AGENT_KV.get(key);
}
*/

# ==========================

# src/router.ts
import type { Env } from "./env";
import { jsonResponse, errorResponse } from "./lib/utils";
import { getAgentRegistry } from "./agents";
import type { AgentInput } from "./agents/baseAgent";

export async function handleRequest(request: Request, env: Env) {
  const url = new URL(request.url);

  if (url.pathname === "/health") {
    return jsonResponse({ ok: true, service: "worker-agent-matrix" });
  }

  if (url.pathname === "/agent/run" && request.method === "POST") {
    const body = (await request.json().catch(() => null)) as
      | {
          agent?: string;
          task: string;
          meta?: Record<string, unknown>;
        }
      | null;

    if (!body || !body.task) {
      return errorResponse("Hiányzik a 'task' mező a body-ban.");
    }

    const agentName = body.agent ?? "orchestrator";
    const registry = getAgentRegistry();
    const agent = registry[agentName];

    if (!agent) {
      return errorResponse(`Ismeretlen agent: ${agentName}`, 404);
    }

    const input: AgentInput = {
      task: body.task,
      meta: body.meta
    };

    const ctx = {
      env,
      requestId: crypto.randomUUID()
    };

    const out = await agent.handle(input, ctx);

    return jsonResponse({
      agent: agent.name,
      output: out
    });
  }

  return errorResponse("Not found", 404);
}

# ==========================

# src/index.ts
import type { Env } from "./env";
import { handleRequest } from "./router";

export default {
  async fetch(request: Request, env: Env, ctx: ExecutionContext) {
    return handleRequest(request, env);
  }
};